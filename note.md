### 1.10 小结

1、计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。

计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。

程序被其他程序翻译成不同的形式，开始时是 ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。【二进制可执行文件】

2、处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。

在层次模型中，位于更高层的存储设备比底层的存储设备要更快，单位比特造价也更高。

层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化 C 程序的性能。

3、操作系统内核是应用程序和硬件之间的媒介。它提供了三个基本的抽象：1）文件是对 I/O 设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理、主存和 I/O 设备的抽象。

最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O 设备。


---
## ch2 信息的表示和处理

2.1 信息存储

大多数计算机使用 8 位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）。

内存的每个字节都由一个唯一的数字来标识，称为它的地址（address），所有可能地址的集合就称为虚拟地址空间（virtual address space）。

**程序对象（program object），即程序数据、指令和控制信息。**

2.1.2 字数据大小

每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长位 w 位的机器而言，虚拟地址的范围为 0~2^w - 1，程序最多访问 2^w 个字节。

将程序称为 “32位程序” 或 “64 位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。


(page 28) 声明指针： 对于任何数据类型 T，声明 `T *p;` 表明 p 是一个指针变量，指向一个类型为 T 的对象。例如，`char *p;` 就将一个指针声明为指向一个 char 类型的对象。

(page 29) 程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。C 语言标准对不同数据类型的数字范围设置了下界，但却没有上界。
因为 1980 年左右到 2010 年左右，32 位机器和 32 位程序使主流的组合，许多程序的编写都假设位图 2-3 中 32位程序的字节分配。随着 64 位机器的日益普及，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖性就会显现出来，成为错误。比如，许多程序假设一个声明位 int 类型的程序对象能被用来存储一个指针。这在大多数 32 位的机器上能正常工作，但是在一台 64 位的机器上却会导致问题。


2.1.3 寻址和字节顺序

对于跨多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。

几乎所有的机器中，多字节对象都被存储为【连续的字节序列】，对象的地址为所使用字节中最小的地址。例如，假设一个类型为 int 的变量 x 的地址为 0x100，也就是说，地址表达式  `&x` 的值为 0x100。那么，（假设数据类型 int 为 32 位表示） x 的 4 字节将被存储在内存的 0x100、0x101、0x102 和 0x103 位置。


排列表示一个对象的字节有两个通用的规则。考虑一个 w 位的整数，其位表示位 [Xw-1, Xw-2, ..., X1, X0]，其中 Xw-1 是最高有效位，而 X0 是最低有效位。假设 w 是 8 的倍数，这些位就能被分组成为字节，其中最高有效位字节包含位 [Xw-1, Xw-2, ..., Xw-8]，而最低有效位字节包含位 [X7, X6, ..., X0]，其他字节包含中间的位。

**小端法(little endian)，最低有效字节在最前面的方式。**
**大端法(big endian)，最高有效字节在最前面的方式。**

![小端法、大端法](./figures/%E6%9C%BA%E5%99%A8%E7%9A%84%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F.png)
对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。

有时候，字节顺序会成为问题。在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接受程序会发现，字里的字节成了反序的。


机器级程序

一条指令的字节级表示



C 代码，使用强制类型转换类访问和打印不同程序对象的字节表示。

用 typedef 将数据类型 byte_pointer 定义为一个指向类型为 "unsigned char" 的对象的指针。这样一个指针引用一个字节序列，其中每个字节都被认为是一个非负整数。

```
// ...
typedef unsinged char *byte_pointer

//...
```

对数值 12 345 编码，它们有截然不同的字节模式：整型为 0x00003039，而浮点数为 0x4640E400。
（以（bit）字节模式存储起来？）

ASCII 字符集适合于编码英语文档，但在表达一些特殊字符方面并没有太多办法，例如法语的“法语C”。它完全不适合编码希腊语、俄语和中文等语言的文档。

#### 2.1.4 表示字符串

基本编码，称为 Unicode 的“统一字符集”，使用 32 位来表示字符。这好像要求文本串中每个字符要占用 4 个字节。不过，可以有一些替代编码，常见的字符只需要 1 个或 2 个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8 表示将每个字符编码位一个字节序列，这样标准 ASCII 字符还是使用和它们在 ASCII 中一样的单字节编码，这也就意味着所有的 ASCII 字节序列用 ASCII 码表示和用 UTF-8 表示是一样的。

标准 ASCII 字符、ASCII 字节序列、ASCII 码表示、UTF-8 表示、字节表示

字节表示的机器代码

---

#### 2.1.5 表示代码
```
int sum (int x, int y) {
    return x + y;
}
```

当我们在示例机器上编译时，生成如下字节所示的机器代码：

![机器代码](./figures/ch2-%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81.png)

我们发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，进行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。


#### 2.1.6 布尔代数简介

二进制值是计算机编码、存储和操作信息的核心，所以围绕数值 0 和 1 的研究已经演化出了丰富的数学知识体系。这起源于 1850 年前后乔治·布尔（George Boole, 1815-1864）的工作，因此也称为布尔代数（Boolean algebra）。

布尔注意到通过将逻辑值 TRUE（真）和 FALSE（假）编码为二进制值 1 和 0，能够设计出一种代数，以研究逻辑推理的基本原则。

最简单的布尔代数是在二元集合 {0, 1} 基础上的定义。

~(NOT) ∧ ∨ | ⊕
&(AND)
|(OR)
^(异或)

![布尔代数的运算](./figures/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97.png)


命题逻辑


创立信息论领域的(Claude Shannon 1916-2001)香农 首先建立了布尔代数和数字逻辑之间的联系。

布尔代数和数字逻辑之间的联系

香农 1937 年的硕士论文中表明了布尔代数可以用来设计和分析机电继电器网络。

我们可以将上述 4 个布尔运算扩展到位向量的运算，位向量就是固定长度为 w、由 0 和 1 组成的串。

位向量的运算

位向量的定义：固定长度为 w、由 0 和 1 组成的串。


__网络旁注 DATA:BOOL__ 关于布尔代数和布尔环的更多内容

布尔环与整数运算有很多相同的属性。例如，整数运算的一个属性是每个值都 x 都有一个加法逆元（additive inverse）-x，使得 x + (-x) = 0 。
布尔环也有类似的属性，这里的“加法”运算是 ^，不过这时每个元素的加法逆元是它自己本身。也就是说，对于任何值 a 来说，a ^ a = 0，这里我们用 0 来表示全 0 的位向量。当我们重新排列组合顺序，这个属性也仍然成立，因此有 (a^b)^a = b。


**颜色的补**：一种颜色的补是通过关掉打开的光源，且打开关闭的光源而形成的。

![红绿蓝色](./figures/ch2-%E7%BA%A2%E7%BB%BF%E8%93%9D-%E7%8E%BB%E7%92%83-%E8%A7%82%E5%AF%9F.png)


#### 2.1.7 C 语言中的位级运算(& | ^)

确定一个位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。


[位级表达式]

位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。
让我们来看一个例子，掩码 0xFF(最低的 8 位为 1) 表示一个字的低位字节。位级运算 x&0xFF 生成一个由 x 的最低效字节组成的值，而其他的字节就被置为 0。

比如，对于 x = 0x89ABCDEF，其表达式将得到 0x000000EF。表达式 ~0 将生成一个全 1 的掩码，不管机器的字大小是多少。尽管对于一个 32 位机器来说，同样的掩码可以写成 0xFFFFFFFF，但这样的代码不是可移植的。


### 2.1.8 C 语言中的逻辑运算(&& || !)

逻辑运算符 && 和 || 与它们对应的位级运算 & 和 | 之间的区别：

区别1、逻辑运算认为所有非零的参数都表示 TRUE，而参数 0 表示 FALSE。它们返回 1 或者 0， 分别表示结果为 TRUE 或者为 FALSE。如下图求值的示例。

![逻辑运算的求值示例](./figures/ch2-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%9A%84%E6%B1%82%E5%80%BC%E7%9A%84%E7%A4%BA%E4%BE%8B.png)

**&& || ! 的运算结果只有 true(1) 或 false(0)**

区别2、如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。因此，例如，表达式 a&&5/a 将不会造成被零除，而表达式 p&&*p++ 也不会导致间接引用空指针。


### 2.19 C 语言中的移位运算

C 语言提供了一组移位运算，向左或向右移动位模式。对于一个位表示为 [Xw-1, Xw-2, ..., X0] 的操作数 X，C 表达式 X << k 会生成一个值，其位表示为 [Xw-k-1, Xw-k-2, ..., X0, 0, ..., 0]。也就是说，X 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。移位量应该是一个 0~ w-1 之间的值。移位运算是从左至右可结合的，所以 X << j << k 等价于 (x << j) << k。

可结合的

机器支持两种形式的右移：逻辑右移和算术右移。

![移位运算](./figures/ch2-%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97-%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB.png)