练习题

1.1 假设你是个卡车司机，要将土豆从爱达荷州的 Boise 运送到明尼苏达州的 Minneapolis，全程 2500 公里。在限速范围内，你估计平均速度为 100 公里/小时，整个行程需要 25 个小时。

A. 你听到新闻说蒙大拿州刚刚取消了限速，这使得行程中有 1500 公里卡车的速度可以为 150 公里/小时。那么这对整个行程的加速比是多少。

(ɑ)耗时比例 = 10 / 25  = 0.4
加速比例因子 = 150 / 100 = 1.5 或者是 

S = 1/((1 - 0.4) + 0.4/0.6) =  0.789

B. 你可以在 www.fasttrucks.com 网站上为自己的卡车买个新的涡轮增压器。网站现货供应各种型号，不过速度越快，价格越高。如果想要让整个行程的加速比为 1.67X，那么你必须以多快的速度通过蒙大拿州？


1.2 公司的市场部向你的客户承诺，下一个版本的软件性能将改进 2X。这项任务被分配给你。你已经确认只有 80% 的系统能够改进，那么，这部分需要被改进多少（即 k 取何值）才能达到整体性能目标？

S = 2
ɑ = 0.8
80 : 20 = 


练习 2.1 完成下面的数字转换：

A. 将 0x39A7F8 转换为二进制。(001110011010011111111000)
B. 将二进制 1100 1001 0111 1011 转换为十六进制。(0xC97B)
C. 将 0xD5E4C 转换为二进制。(1101 0101 1110 0100 1100)
D. 将二进制 (00)10 0110 1110 0111 1011 0101 转换为十六进制。(0x26D7B5)

---
当值 x 是 2 的非负整数 n 次幂时，也就是 x = 2^n，我们可以很容易地将 x 写成十六进制形式，只要记住 x 的二进制表示就是 1 后面跟 n 个 0。十六进制数字 0 代表 4 个二进制 0。

所以，当 n 表示成 i + 4j 的形式，其中 0 <= i <= 3，我们可以把 x 写成开头的十六进制数字为 1(i=0)、2(i=1)、4(i=2)或者 8(i=3)，后面跟随着 j 个十六进制的 0。比如，x = 2048 = 2^11，我们有 n = 11 = 3 + 4 * 2，从而得到十六进制表示 0x800。(2^(3+ 4*2))

---

十进制和十六进制表示之间的转换需要使用乘法或者除法来处理一般情况。将一个十进制数字 x 转换为十六进制，可以反复地用 16 除 x，得到一个商 q 和一个余数 r，也就是 x = q * 16 + r。然后我们用十六进制数字表示的 r 作为最低位数字，并且通过对 q 反复进行这个过程得到剩下的数字。

-  314 156  =   19634 * 16 + 12 (C)
-   19634   =   1227 * 16 + 2 (2)
-   1227   = 76 * 16 + 11  (B)
-   76 = 4 * 16 + 12 (C)
-   4 = 0 * 16 + 4 (4)
从这里，能读出十六进制表示为 0x4CB2C。反过来，将一个十六进制数字转换为十进制数字，可以用相应的 16 的幂乘以每个十六进制数字。比如，给定数字 0x7AF，计算它对应的十进制值为 7 * 16^2 + 10 * 16 + 15。


### 2.10 
void inplace_swap(int *x, int *y) {
    *y = *x ^ *y    // step1
    *x = *x ^ *y    // step2
    *y = *x ^ *y    // step3
}

/*
    *x          *y
    a           b
    a           a^b
    a^a^b       a^b
    a^a^b   a^a^b^a^b   
*/

### 2.11

void reverse_array(int a[], int cnt) {
    int first, last;
    for (first = 0, last = cnt -1;
        first <= last;
        first++, last--)
        inplace_swap(&a[first], &a[last])
        // 偶数数组没问题，奇数数组会出现中间位被设置为 0。如：5 4 3 2 1 -> 1 2 0 4 5
}


### 2.12

A. x = 0x87654321 & 0xFF

B. x = 0x87654321 ^ 0xFFFFFF?? (取补，最低有效字节保持不变)

C. x = 0x87654321 ^ 0x21 & 0xFF

### 2.13 

// Declarations of functions implementing operations bis and bic
int bis(int x, int m)
int bic(int x, int m)

// Compute x | y using only calls to functions bis and bic
int bool_or(int x, int y) {
    int result = ____;
    return result;
}

int bool_xor(int x, int y) {
    int result = ____;
    return result;
}

### 2.14 

x = 0x66 y = 0x39

x & y -> 0x0110 0110 & 0x0011 1001
x | y -> [01100110] | [00111001]
~x | ~y -> [10011001] | [11000110]
x & !y -> [0x01100110] & [1100 0110]
x && y -> 0x01
x || y -> 0x01
!x || !y -> 0x00
x && !y   -> 0x00

### 2.15 只使用位级和逻辑运算，编写一个 C 表达式，它等价于 x == y。换句话说，当 x 和 y 相等时它将返回 1，否则返回 0。


```
bool bool_equal(int x, int y) {

    // a ^ a = 0 //  x ^ y = 0 // it means x equal to y
    return !(x ^ y);
} 

```


### 2.16 

x                   x<<3             x >> 2(逻辑的)     x >> 2(算术的)

0xC3/0x1100 0011    0x0001 1000     0x0011 0000       0x1111 0000
0x75/0x0111 0101    0x1001 0100     0x0011 0101       0x0011 0101
0x87/0x1000 0111    0x0011 1000     0x0000 0111       0x1110 0111
0x66/0x0110 0110    0x0011 0000     0x0011 0011       0x0001 1001

### 2.17 

    x               B2U4(x)                 B2T4(x)
0xE [1110]          2^3+2^2+2^1             -2^3+2^2+2^1 = -2
0x0 [0000]          0                       0*-2^3 = 0
0x5 [0101]          1*2^2 + 1 * 2^0         0*-2^3 + 1*2^2 + 1*2^0 = 5
0x8 [1000]          1*2^3                   1*-2^3 = -8
0xD [1101]          1*2^3 + 1*2^2 + 1*2^0   1*-2^3 + 2^2 + 2^0 = -3
0xF [1111]          2^3+2^2+2+2^0           1*-2^3 + 2^2 + 2^1 + 2^0 = -1


